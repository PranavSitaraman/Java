Objects and Classes A Java program is really a series of interacting objects, in much the same way that a corporation is a series of interacting departments. In a typical corporation, each department has its own role, and its own data associated with that role. For example, imagine a modern museum. It has a Communications department, whose purpose is to provide the interface to the museum’s public. It communicates with the outside world, does marketing, conducts visitor satisfaction surveys, and processes that data. When there is a crisis, all contact with the media is supposed to go through the Communications department. There is a Human Resources department, whose job is to coordinate the hiring and support of its employees. It is responsible for issuing badges and credentials to its employees so that they can recognize each other as official employees of the museum. It also handles payroll and salary, and it is the only department in the company that has access to employees’ salary data. A museum has an Exhibits department, which is responsible for maintaining the collections of the museum. Only 10% of the collection is normally on display at any given time, so new paintings and sculptures must be rotated to the front based on what is in demand. The Exhibits department is responsible for keeping track of dates, locations, and approximate value of every item in the museum’s collection. So far, we have mainly been working in one main method, and calling methods from the same class to perform different tasks. But in an object-oriented language such as Java, proper design really divides a program up into different classes, and each class has its own particular job. For example, one design pattern is called MVC, which stands for Model-View-Controller. In your Java program, you might have one View class that manages all input from the user, and all output to the screen, kind of like the Communications department. You might have one Controller class that manages and coordinates the work of the different classes that make up the program, routing requests for information back and forth, kind of like the Human Resources department. And finally, you might have a Model class, that works with the various data structures in your program and retrieves information on demand, kind of like the Exhibits department. Every class has its own role, and access to data is compartmentalized so nothing gets changed or modified without authorization. Parts of a Class A class is a Java file that contains all of the instructions for how to make a new object. Objects have behaviors – things that they do – and they have attributes – things that they know. Suppose we have a six-sided number cube, also known as a die. The die should know how many sides it has – it’s a cube, so we’ll say it has six sides – and it should know how to roll – it will return a random number from one to six, representing a single roll of the die. public class Die // Instance variable private int numSides; // Constructor public Die() { numSides = 6; } // Method public int roll() { Random rand = new Random(); return rand.nextInt(numSides) + 1; } The Die class knows how many sides it has, and it stores that information in a variable called an instance variable whose value gets set at the time the Die is constructed, and does not change. The Die also knows how to roll, and will return a random number any time its roll() method is called. Aspects of Object data * an object is a method of storing multiple pieces of data and the methods who act on this data under a single data type * this means within a single object you could have multiple pieces of data including both primitives and other objects * because objects have the potential to store large amounts of data Java stores them in memory differently from primitives, storing the location for the data in the actual variable as a "reference" Instance Variables Attributes of a class describe the state of an object. For example, you can have a boolean variable called gameWon that describes whether that game has been won or not. A Car class might have instance variables for color, number of wheels, or whether or not it has heated seats. Attribute data is stored in variables right at the top of the class, and not in a method or a constructor. They are typically marked private because they are only supposed to be accessed by methods within the class itself. If you don’t initialize an instance variable when you declare it, Java will provide a default value based on the data type of the instance variable. Instance variables are also commonly known as fields. public class MyObject { String field1 = ""; int field2 = 0; double field3 = 0.0; ... } Defining the fields outside any method gives them the scope of the entire class. This means that they can be used by any method within the class, so you should try to limit them to those values that are strictly necessary. You need to determine what Java data type to use, and they can be a primitive data types or any type of object including other classes that you have defined. Here’s what a Bicycle object might have: public class Bicycle { String brand = ""; String model = ""; double listPrice = 0.0; int tireSize = 24; boolean isSold = false; double salePrice = 0.0; ... } These are the aspects of a bicycle that are most important for the shop owner and that describe the bike, so they are created as attributes, or instance variables (fields). Instance variables can be objects as well. For example, you could create a list of all the different accessories that come installed on the bike: ArrayList<String> accessoryList = new ArrayList<String>(); These accessories might even be objects themselves, defined in Accessory.java; if so, the data type declaration would be: ArrayList<Accessory> accessoryList = new ArrayList<Accessory>(); As shown, the naming convention for fields is to use nouns in camelCase. Using Instance Variables Once you've created an instance variable it works just like any other variable. You refer to it by name whenever you need to use it within your object's code. public class Bicycle { double listPrice = 899.99; double salePrice = 599.99; // Updates the price of the bicycle to be the reduced sale price public void setSale() { listPrice = salePrice; } } This Keyword Sometimes it can get confusing between what parameters are inside your class and which are being passed in from an external source. To help make this more clear you can add the "this" keyword in front of your object fields. For example, you might have a method that takes in a parameter from the client that you want to save into the value of your field. You can use the this keyword to make it easier to distinguish between the parameter and the field. public void setPrice(double newPrice) { this.listPrice = newPrice; } We will learn more situations in which to use the "this" keyword in the following sections. Constructors Recall that a client class creates objects by using the new operator with a statement similar to this one: Bicycle bike1 = new Bicycle("Giant","OCR-1",899.99,28); The right hand side of the declaration resembles a method call that takes in parameters. This is because the keyword "new" does call a special method called a constructor. To review, recall that a constructor is a special method that can perform specific actions when a new object is created from a class. Often a constructor is used to set the instance variables of the class. You can have more than one constructor in a class but just like overloaded methods, overloaded constructors need to have different method signatures. The name of a constructor is always the same as the name of the class, and it does not have a return type. If you do not include a constructor when you create a class, Java will provide a default one for you that constructs a new object and does nothing else. However, if you do provide a custom constructor that takes a parameter, Java will not provide a default constructor that takes no parameters; if you want some sort of default behavior, you will need to provide that default constructor yourself. Writing Constructors In your object class you can specify what happens when your client calls the "new" keyword by adding a special type of method, the constructor. Here is how we might write the constructor for our Bicycle class: public Bicycle (String myBrand, String myModel, double myPrice) { this.brand = myBrand; this.model = myModel; this.price = myPrice; } Notice that there are a couple of things in the constructor header that are different from typical methods: * The name of the method is the class name "Bicycle" * There is no return type (void, int, etc.) specified for the method, because a constructor will always return an object of its own class. If you specify a return type by mistake, even void, you will have a standard method, not a constructor, and the client call above won’t work. The general format for a constructor header is: public ClassName (parameters) { Since the constructor is called when creating a new instance of an object you will want to do any work to set up the object for use by the client. Often this means initializing the fields. If we want the user to be able to specify the initial values for the fields, we need parameters that match the fields. public class Bicycle { String myBrand; String myModel; double myPrice; boolean isSold; double salePrice; public Bicycle (String brand, String model, double price) { myBrand = brand; myModel = model; myPrice = price; isSold = false; salePrice = 0.0; } } Things to note: * This constructor only accepts the value of three fields from the client; the other fields are set to defaults. * Because we set all the fields' values within the constructor we no longer need to set their values at their declaration. This approach of splitting declaration and initialization is the preferred style. * Don't get the statements backwards and write brand = myBrand! If you do that you will update the parameter variable which disappears once the constructor is exited. Remember that = means "takes the value of". * We used different names for the parameters than the fields, but because they store the same type of data it’s really tempting to write: public Bicycle (String brand, String model, double price) { brand = brand; model = model; price = price; ... But this will not set the values of the fields! Remember that parameters create local variables of the same name in the scope of a method, and that variable will "mask" the field of the same name in this method, so brand = brand uselessly sets itself to its own value. Oops! Java does permit you to explicitly qualify that you want the object to refer to its own field by using the keyword this. You could write the constructor using the field names as parameter names as long as you emphasize the difference with the "this" keyword: public Bicycle (String brand, String model, double price) { this.brand = brand; this.model = model; this.price = listPrice; ... Default Constructors You do not have to provide a constructor for an object at all. If you don’t, Java provides a default for you known as the default constructor that takes zero arguments. In the case of our Bicycle class it would look like this: public Bicycle() { } If you do not specify a constructor yourself, then when the client class creates a new object it cannot pass in any arguments. This means that the fields will initially store their default values. Bicycle bike1 = new Bicycle(); Default Constructors You can in fact have as many constructors as you like through overloading. In this way you can allow users to decide what amount of data they want to specify when creating and object, and what amount they want to rely on default values. To do this properly you should first create a class that initializes all fields inside the constructor: public class Bicycle { String brand; String model; double price; int tireSize; boolean isSold; double salePrice; public Bicycle (String brand, String model, double price, boolean isSold, double salePrice) { this.brand = brand; this.model = model; this.price = price; this.isSold = isSold; this.salePrice = salePrice; } } Reducing Redundancy with "this" Notice that we have moved all the field declarations within the constructor, giving the user complete control over the initial state of the object. Now that this constructor exists you can add other constructors that include default values so your user doesn't have to set everything. You can call the most specific constructor from the less specific constructors to reduce redundancy. You call one constructor from the other with the use of the "this" keyword in the place a method name would normally be. If some bikes don’t have a model, for example, you could provide: // this uses the default values of 28 for the tireSize // false for isSold and set the salePrice to the listPrice public Bicycle(String brand, String model, double listPrice) { this(brand, model, listPrice, 28, false, listPrice); } // this uses all default values for a new Bicycle public Bicycle() { this("", "", 0.0, 28, false, 0.0); } Now we can create new Bicycles in our client class with differing levels of initial information like so: Bicycle specificBike = new Bicycle("Giant","OCR-1",899.99,28,false,599.99); Bicycle genericBike = new Bicycle("Schwin","Cruiser",250.00); Bicycle defaultBike = new Bicycle(); Methods Methods describe the behavior of an object. They can be public, meaning other objects can access them, or they can be private, in which case only the object containing them can access them. Sometimes you might create a "helper" method to help other methods in that object do their job; a private helper method might find and return the largest item in a list, for example. One common use of methods is to get and set the values of private instance variables. Defining Methods You write methods for an object the same way you’ve written other methods, except you omit the static property. public returnType methodName(parameters) { statements; } You will want to define your methods after your instance variables within your class, like so: public class MyClass { String field1 = ""; int field2 = 0; public void updateField(int param) { field2 = param; } } Remember that the job of these methods is to perform some action, so they generally should have names that begin with verbs such as "get", "set", and "calculate". As this work is typically performed on the fields, you will usually want to combine your verb with the name of the field this method acts upon. Let's look at our Bicycle example. Our Bicycle field has the following fields: public class Bicycle { String brand = ""; String model = ""; double listPrice = 0.0; int tireSize = 24; boolean isSold = false; double salePrice = 0.0; ... This Bicycle class is intended to be used by shopkeepers who sell Bicycles, so some things they might want to do are: // returns a String with basic information about // the bicycle public String getInfo() { return brand + " " + model + " $" + price; } // marks the bicycle as sold and returns // the asking price for the customer public double makeFullPriceSale() { isSold = true; return listPrice; } // marks the bicycle as sold and returns // the asking price for the customer // during a sale public double makeReducedPriceSale() { isSold = true; return salePrice; } Notice that we can create behaviors based on what a user might want to be able to do with the fields. Working with Other Objects Your object's methods can access the field in other objects of the same type. For example, in our Bicycle object we could implement an equals method that determines whether two Bicycle objects have the same brand and model like so: public boolean equals(Bicycle other) { return brand.equals(other.brand) && model.equals(other.model); } This is another case where the "this" keyword could help make things more clear. The above method could be rewritten: public boolean equals(Bicycle other) { return this.brand.equals(other.brand) && this.model.equals(other.model); } The client code would use this method on two separate Bicycle variables, like so: Bicycle bike1 = new Bicycle("Schwinn", "Cruiser"); Bicycle bike2 = new Bicycle("Giant", "Racer"); if (bike1.equals(bike2)) { // in this case would return false bike2.listPrice = bike1.listPrice; } 
